<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Cosmic Hand Galaxy - Manual Load</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Courier New', monospace; }
        
        /* æ‹–æ‹½åŒºåŸŸ UI */
        #drop-zone {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; color: #ffd700; text-align: center;
            transition: opacity 0.5s;
        }
        .box {
            border: 2px dashed #ffd700; padding: 40px; border-radius: 10px;
            background: rgba(255, 215, 0, 0.1);
            max-width: 80%;
        }
        h1 { margin: 0 0 10px 0; font-size: 24px; text-shadow: 0 0 10px #ffd700; }
        p { color: #aaa; margin: 5px 0; }
        .highlight { background: rgba(255, 215, 0, 0.2); border-color: #fff; }
        
        #video-input { position: absolute; opacity: 0; pointer-events: none; }
        #log { position: absolute; bottom: 10px; left: 10px; color: lime; font-size: 12px; z-index: 50; pointer-events: none; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/",
                "@mediapipe/tasks-vision": "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/+esm"
            }
        }
    </script>
</head>
<body>

    <!-- æ‹–æ‹½äº¤äº’å±‚ -->
    <div id="drop-zone">
        <div class="box" id="drop-box">
            <h1>ğŸ– å¯åŠ¨æ˜Ÿç³»å¼•æ“</h1>
            <p>ç”±äºç½‘ç»œé™åˆ¶ï¼Œéœ€è¦æ‰‹åŠ¨åŠ è½½æ¨¡å‹ã€‚</p>
            <p style="color: white; font-weight: bold; margin-top: 20px;">
                è¯·æŠŠæ¡Œé¢ä¸Šçš„ "hand_landmarker.task" æ–‡ä»¶<br>æ‹–æ‹½åˆ°è¿™é‡Œï¼
            </p>
        </div>
    </div>

    <div id="log">Waiting for manual injection...</div>
    <video id="video-input" playsinline autoplay></video>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { FilesetResolver, Hands } from '@mediapipe/tasks-vision';

        // --- UI é€»è¾‘ ---
        const dropZone = document.getElementById('drop-zone');
        const dropBox = document.getElementById('drop-box');
        const logDiv = document.getElementById('log');

        function log(msg) { logDiv.innerHTML += "<br>" + msg; }

        // æ‹–æ‹½äº‹ä»¶ç›‘å¬
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
            dropZone.addEventListener(eventName, preventDefaults, false);
        });
        function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }

        dropZone.addEventListener('dragenter', () => dropBox.classList.add('highlight'));
        dropZone.addEventListener('dragleave', () => dropBox.classList.remove('highlight'));
        
        // æ ¸å¿ƒï¼šå¤„ç†æ–‡ä»¶æ”¾ç½®
        dropZone.addEventListener('drop', handleDrop, false);

        function handleDrop(e) {
            dropBox.classList.remove('highlight');
            const dt = e.dataTransfer;
            const files = dt.files;

            if (files.length > 0) {
                const file = files[0];
                if (file.name.includes('.task')) {
                    log(`Received file: ${file.name}`);
                    dropBox.innerHTML = "<h1>ğŸš€ Loading...</h1><p>Injecting model into memory...</p>";
                    // åˆ›å»ºæœ¬åœ° Blob URLï¼Œç»•è¿‡ç½‘ç»œä¸‹è½½
                    const objectUrl = URL.createObjectURL(file);
                    initAI(objectUrl);
                } else {
                    alert("è¯·æ‹–å…¥æ­£ç¡®çš„ .task æ–‡ä»¶ï¼");
                }
            }
        }

        // --- 1. Three.js åœºæ™¯ ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x020008, 0.002);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        composer.addPass(new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 2.5, 0.5, 0.1));

        // ç²’å­ç³»ç»Ÿ
        const particleCount = 40000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const randoms = new Float32Array(particleCount * 3);
        const colorInside = new THREE.Color(0xffaa00);
        const colorOutside = new THREE.Color(0x2e004d);

        for (let i = 0; i < particleCount; i++) {
            const i3 = i * 3;
            const r = Math.random() * 5;
            const angle = r * 4 + (i % 3) * 2;
            positions[i3] = Math.cos(angle)*r + (Math.random()-0.5);
            positions[i3+1] = (Math.random()-0.5)*0.5;
            positions[i3+2] = Math.sin(angle)*r + (Math.random()-0.5);
            
            const c = colorInside.clone().lerp(colorOutside, r/5);
            colors[i3] = c.r; colors[i3+1] = c.g; colors[i3+2] = c.b;
            randoms[i3] = Math.random(); randoms[i3+1] = Math.random(); randoms[i3+2] = Math.random();
        }
        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute('aRandom', new THREE.BufferAttribute(randoms, 3));

        const material = new THREE.ShaderMaterial({
            vertexShader: `
                uniform float uTime; uniform vec3 uTarget; uniform float uPinch;
                attribute vec3 color; attribute vec3 aRandom; varying vec3 vColor;
                void main() {
                    vColor = color;
                    vec3 pos = position;
                    float angle = uTime * 0.2 * (1.0/(length(pos)+0.1));
                    float c = cos(angle); float s = sin(angle);
                    vec3 rot = vec3(pos.x*c - pos.z*s, pos.y, pos.x*s + pos.z*c);
                    vec3 final = rot + uTarget;
                    if(uPinch > 0.0) {
                        final = mix(final, uTarget, uPinch * (0.8 + aRandom.x));
                        final += (aRandom - 0.5) * uPinch * 0.5;
                    }
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(final, 1.0);
                    gl_PointSize = (20.0 * aRandom.x + 5.0) / -gl_Position.z;
                }
            `,
            fragmentShader: `
                varying vec3 vColor;
                void main() {
                    float d = distance(gl_PointCoord, vec2(0.5));
                    if(d>0.5) discard;
                    gl_FragColor = vec4(vColor * 2.0, pow(1.0-d*2.0, 3.0));
                }
            `,
            uniforms: { uTime: { value: 0 }, uTarget: { value: new THREE.Vector3() }, uPinch: { value: 0 } },
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        scene.add(new THREE.Points(geometry, material));

        // --- 2. AI åˆå§‹åŒ– (æ‰‹åŠ¨æ³¨å…¥) ---
        let handLandmarker;
        let lastVideoTime = -1;
        const video = document.getElementById('video-input');
        
        let targetPos = new THREE.Vector3();
        let currentPos = new THREE.Vector3();
        let pinch = 0;

        async function initAI(modelUrl) {
            try {
                log("Initializing FilesetResolver (CDN)...");
                const vision = await FilesetResolver.forVisionTasks(
                    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.0/wasm"
                );
                
                log("Loading Model from Local Blob...");
                handLandmarker = await Hands.createFromOptions(vision, {
                    baseOptions: {
                        modelAssetPath: modelUrl, // <--- è¿™é‡Œç›´æ¥ç”¨ä½ æ‹–è¿›å»çš„æ–‡ä»¶
                        delegate: "GPU"
                    },
                    runningMode: "VIDEO",
                    numHands: 1
                });

                log("Model Loaded! Requesting Camera...");
                startCamera();
            } catch (err) {
                log("Error: " + err.message);
                dropBox.innerHTML = `<h1>âŒ Error</h1><p>${err.message}</p>`;
            }
        }

        function startCamera() {
            navigator.mediaDevices.getUserMedia({ video: true }).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", () => {
                    log("Camera Active. Starting loop.");
                    dropZone.style.opacity = 0; // æˆåŠŸåéšè—ç•Œé¢
                    setTimeout(() => dropZone.style.display = 'none', 500);
                    predict();
                });
            }).catch(err => {
                log("Camera Error: " + err.message);
                alert("è¯·å…è®¸æ‘„åƒå¤´æƒé™ï¼");
            });
        }

        function predict() {
            if (handLandmarker && video.currentTime !== lastVideoTime) {
                lastVideoTime = video.currentTime;
                const result = handLandmarker.detectForVideo(video, performance.now());
                if(result.landmarks.length > 0) {
                    const lm = result.landmarks[0];
                    const x = (1 - lm[9].x) * 2 - 1;
                    const y = -(lm[9].y * 2 - 1);
                    targetPos.set(x*6, y*3.5, 0);
                    const d = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    pinch += ((d<0.06?1:0) - pinch) * 0.1;
                }
            }
            requestAnimationFrame(predict);
        }

        const clock = new THREE.Clock();
        function animate() {
            const dt = clock.getElapsedTime();
            currentPos.lerp(targetPos, 0.1);
            material.uniforms.uTime.value = dt;
            material.uniforms.uTarget.value = currentPos;
            material.uniforms.uPinch.value = pinch;
            scene.rotation.y = currentPos.x * 0.1;
            composer.render();
            requestAnimationFrame(animate);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth/window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
