<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Dr. Strange AR - Optimized</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* 1. è§†é¢‘å±‚ï¼šè°ƒé«˜äº®åº¦ï¼Œè®©ä½ çœ‹æ¸…è‡ªå·± */
        #video-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 0; opacity: 0.8; /* ä¹‹å‰æ˜¯0.4ï¼Œç°åœ¨æ”¹ä¸º0.8ï¼Œæ›´æ¸…æ™° */
        }
        video {
            width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
        }

        /* 2. è°ƒè¯•å±‚ï¼šç»˜åˆ¶æ‰‹éƒ¨éª¨æ¶ */
        #debug-canvas {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 1; pointer-events: none;
        }

        /* 3. ç‰¹æ•ˆå±‚ */
        #three-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 2; pointer-events: none;
        }

        /* UI é¢æ¿ */
        #ui-layer {
            position: absolute; top: 10px; left: 10px; z-index: 10;
            color: #00ff00; font-family: monospace; font-size: 14px;
            text-shadow: 1px 1px 2px black;
            pointer-events: none;
        }
        .status-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 10px; border-radius: 8px; border: 1px solid #444;
            margin-bottom: 10px;
        }
        #gesture-indicator {
            font-size: 24px; font-weight: bold; color: #ffaa00;
            transition: color 0.3s;
        }

        /* å¯åŠ¨æŒ‰é’® */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.95); z-index: 999;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            pointer-events: auto;
        }
        button {
            background: #ffaa00; border: none; color: #000;
            padding: 15px 40px; font-size: 20px; font-weight: bold;
            cursor: pointer; border-radius: 50px; margin-top: 20px;
        }
    </style>
    
    <!-- å¼•å…¥ MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <!-- å¼•å…¥ Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="start-screen">
        <h1 style="color:#ffaa00">é­”æ³•é˜µç³»ç»Ÿ V2.0</h1>
        <p style="color:#aaa">ä¼˜åŒ–äº†æ‰‹åŠ¿è¯†åˆ«ä¸è§†é‡æ˜¾ç¤º</p>
        <button onclick="startApp()">å¯åŠ¨æ‘„åƒå¤´</button>
    </div>

    <div id="video-container"><video id="input_video" playsinline></video></div>
    <canvas id="debug-canvas"></canvas>
    <div id="three-container"></div>

    <div id="ui-layer">
        <div class="status-box">
            <div>çŠ¶æ€: <span id="status-text">ç­‰å¾…å¯åŠ¨...</span></div>
            <div id="gesture-indicator">NONE</div>
            <div style="font-size:10px; color:#aaa; margin-top:5px">
                ğŸ– å¼ å¼€: æŠ¤ç›¾<br>ğŸ‘Œ æåˆ: æ—¶é—´<br>âœŠ æ¡æ‹³: æ¯ç­
            </div>
        </div>
        <div class="status-box">
            <div>æ‰‹æŒå¤§å°: <span id="palm-size">0</span></div>
            <div>æŒ‡å°–è·ç¦»: <span id="finger-dist">0</span></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        let camera3D, scene, renderer, composer;
        let shieldGroup, particles, timeRing, layerCore, layerMid, layerOut;
        let activeHand = null;
        let currentState = 'SHIELD';
        
        // è°ƒè¯•ç”»å¸ƒ
        const debugCanvas = document.getElementById('debug-canvas');
        const debugCtx = debugCanvas.getContext('2d');

        // === 1. Three.js åˆå§‹åŒ– (ä¿æŒç‰¹æ•ˆä¸å˜) ===
        function initThree() {
            const container = document.getElementById('three-container');
            const w = window.innerWidth; const h = window.innerHeight;
            scene = new THREE.Scene();
            camera3D = new THREE.PerspectiveCamera(60, w / h, 0.1, 100);
            camera3D.position.z = 10;
            renderer = new THREE.WebGLRenderer({ alpha: true, antialias: false });
            renderer.setSize(w, h);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
            container.appendChild(renderer.domElement);
            
            // è¾‰å…‰
            const renderScene = new RenderPass(scene, camera3D);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(w, h), 1.5, 0.4, 0.85);
            bloomPass.strength = 2.0; bloomPass.radius = 0.5; bloomPass.threshold = 0;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createMagicAssets();
        }

        // === 2. é­”æ³•èµ„äº§ ===
        function createMagicAssets() {
            const size = 1024;
            const cvs = document.createElement('canvas'); cvs.width = size; cvs.height = size;
            const ctx = cvs.getContext('2d');
            
            // ç»˜åˆ¶é«˜æ¸…çº¹ç†
            ctx.translate(512, 512);
            ctx.shadowBlur=10; ctx.shadowColor='white'; ctx.strokeStyle='white'; ctx.lineWidth=8;
            
            // æ–¹é˜µ
            ctx.save();
            for(let i=0; i<2; i++) { ctx.rotate(Math.PI/4); ctx.strokeRect(-280, -280, 560, 560); }
            ctx.restore();
            
            // ç¬¦æ–‡åœˆ
            ctx.beginPath(); ctx.arc(0,0, 380, 0, Math.PI*2); ctx.stroke();
            ctx.beginPath(); ctx.arc(0,0, 480, 0, Math.PI*2); ctx.stroke();
            
            // éšæœºç¬¦æ–‡
            ctx.lineWidth=4;
            for(let i=0; i<36; i++) {
                ctx.save(); ctx.rotate(i*Math.PI*2/36); ctx.translate(0, -420);
                ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(Math.random()*20-10, 20); ctx.stroke();
                ctx.restore();
            }

            const tex = new THREE.CanvasTexture(cvs);
            const mat = new THREE.MeshBasicMaterial({ map: tex, color: 0xffaa00, transparent: true, side: THREE.DoubleSide, blending: THREE.AdditiveBlending, depthWrite: false });

            shieldGroup = new THREE.Group();
            scene.add(shieldGroup);

            layerCore = new THREE.Mesh(new THREE.PlaneGeometry(5,5), mat.clone());
            layerMid = new THREE.Mesh(new THREE.PlaneGeometry(7,7), mat.clone()); layerMid.position.z = 0.5;
            layerOut = new THREE.Mesh(new THREE.PlaneGeometry(9,9), mat.clone()); layerOut.position.z = 1.0;
            
            timeRing = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.1, 16, 100), mat.clone()); timeRing.visible = false;

            const pGeo = new THREE.BufferGeometry();
            const pPos = new Float32Array(900);
            for(let i=0; i<900; i++) pPos[i] = (Math.random()-0.5)*10;
            pGeo.setAttribute('position', new THREE.BufferAttribute(pPos, 3));
            particles = new THREE.Points(pGeo, new THREE.PointsMaterial({color:0xffaa00, size:0.1, transparent:true, blending:THREE.AdditiveBlending}));

            shieldGroup.add(layerCore, layerMid, layerOut, timeRing, particles);
            shieldGroup.visible = false;
        }

        // === 3. å¯åŠ¨é€»è¾‘ ===
        window.startApp = async function() {
            document.getElementById('start-screen').style.display = 'none';
            initThree();
            animate();
            
            const video = document.getElementById('input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1,
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });
            hands.onResults(onResults);

            const cam = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 1280, height: 720
            });
            cam.start();
        };

        // === 4. æ‰‹åŠ¿è¯†åˆ«æ ¸å¿ƒä¼˜åŒ– (å…³é”®ä¿®æ”¹) ===
        function onResults(results) {
            // 1. ç»˜åˆ¶è°ƒè¯•éª¨æ¶ (å¯è§†åŒ–)
            debugCanvas.width = window.innerWidth; debugCanvas.height = window.innerHeight;
            debugCtx.clearRect(0, 0, debugCanvas.width, debugCanvas.height);
            
            // é•œåƒç¿»è½¬ Canvas ä»¥åŒ¹é…è§†é¢‘
            debugCtx.save();
            debugCtx.scale(-1, 1);
            debugCtx.translate(-debugCanvas.width, 0);

            if (results.multiHandLandmarks.length > 0) {
                document.getElementById('status-text').innerText = "å·²é”å®šç›®æ ‡";
                document.getElementById('status-text').style.color = "#00ff00";
                
                const landmarks = results.multiHandLandmarks[0];
                activeHand = landmarks;
                shieldGroup.visible = true;

                // ç»˜åˆ¶éª¨æ¶çº¿
                drawConnectors(debugCtx, landmarks, HAND_CONNECTIONS, {color: '#00ff00', lineWidth: 2});
                drawLandmarks(debugCtx, landmarks, {color: '#ff0000', lineWidth: 1, radius: 3});

                // === æ™ºèƒ½æ‰‹åŠ¿ç®—æ³• ===
                
                // A. è®¡ç®—æ‰‹æŒå‚è€ƒå¤§å° (æ‰‹è…• -> ä¸­æŒ‡æ ¹)
                // è¿™è§£å†³äº†â€œè·ç¦»è¿œè¿‘â€å¯¼è‡´è¯¯åˆ¤çš„é—®é¢˜
                const wrist = landmarks[0];
                const middleBase = landmarks[9];
                const palmSize = Math.hypot(wrist.x - middleBase.x, wrist.y - middleBase.y);
                
                document.getElementById('palm-size').innerText = palmSize.toFixed(3);

                // B. è®¡ç®—æ‰‹æŒ‡åˆ°æ‰‹è…•çš„å¹³å‡è·ç¦»
                const tips = [8, 12, 16, 20]; // é£ŸæŒ‡ã€ä¸­æŒ‡ã€æ— åæŒ‡ã€å°æŒ‡å°–
                let totalTipDist = 0;
                tips.forEach(idx => {
                    totalTipDist += Math.hypot(landmarks[idx].x - wrist.x, landmarks[idx].y - wrist.y);
                });
                const avgTipDist = totalTipDist / 4;
                
                // è®¡ç®—â€œç´§å‡‘åº¦â€ = æŒ‡å°–è·ç¦» / æ‰‹æŒå¤§å°
                // å¼ å¼€æ‰‹æ—¶ï¼Œè¿™ä¸ªå€¼é€šå¸¸ > 1.5
                // æ¡æ‹³æ—¶ï¼Œè¿™ä¸ªå€¼é€šå¸¸ < 0.8
                const compactness = avgTipDist / palmSize;
                document.getElementById('finger-dist').innerText = compactness.toFixed(2);

                // C. è®¡ç®—æåˆè·ç¦» (æ‹‡æŒ‡å°– -> é£ŸæŒ‡å°–)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];
                const pinchDist = Math.hypot(thumbTip.x - indexTip.x, thumbTip.y - indexTip.y);
                const normalizedPinch = pinchDist / palmSize; // å½’ä¸€åŒ–æåˆå€¼

                // === çŠ¶æ€åˆ¤å®š ===
                let newState = 'SHIELD';
                const label = document.getElementById('gesture-indicator');

                // é˜ˆå€¼åˆ¤å®š (æ¯”ç»å¯¹è·ç¦»æ›´ç¨³)
                if (compactness < 0.9) { 
                    newState = 'CHAOS'; // æ¡æ‹³
                    label.innerText = "CHAOS (æ¯ç­)";
                    label.style.color = "#ff0000";
                } else if (normalizedPinch < 0.25) {
                    newState = 'TIME'; // æåˆ
                    label.innerText = "TIME (æ—¶é—´)";
                    label.style.color = "#00ff00";
                } else {
                    newState = 'SHIELD'; // é»˜è®¤å¼ å¼€
                    label.innerText = "SHIELD (æŠ¤ç›¾)";
                    label.style.color = "#ffaa00";
                }

                updateVisuals(newState);
                updatePosition(landmarks, palmSize);

            } else {
                document.getElementById('status-text').innerText = "æœç´¢æ‰‹éƒ¨ä¿¡å·...";
                document.getElementById('status-text').style.color = "#ffff00";
                activeHand = null;
                if(shieldGroup) shieldGroup.visible = false;
            }
            debugCtx.restore();
        }

        function updateVisuals(state) {
            currentState = state;
            let targetColor = new THREE.Color(0xffaa00);
            
            if(state === 'TIME') {
                targetColor.setHex(0x00ff00);
                timeRing.visible = true; layerCore.visible = false;
            } else if (state === 'CHAOS') {
                targetColor.setHex(0xff0000);
                timeRing.visible = false; layerCore.visible = true;
            } else {
                targetColor.setHex(0xffaa00);
                timeRing.visible = false; layerCore.visible = true;
            }

            layerCore.material.color.lerp(targetColor, 0.2);
            layerMid.material.color.lerp(targetColor, 0.2);
            layerOut.material.color.lerp(targetColor, 0.2);
            particles.material.color.lerp(targetColor, 0.2);
            timeRing.material.color.lerp(targetColor, 0.2);
        }

        function updatePosition(landmarks, palmSize) {
            // æ˜ å°„ä½ç½®
            const midBase = landmarks[9];
            const wrist = landmarks[0];
            const midTip = landmarks[12];
            
            // åæ ‡è½¬æ¢ (MediaPipe 0-1 -> Three.js è§†å£)
            // å‡è®¾ Z=10, è§†å£å®½é«˜çº¦ä¸º 18x10
            const x = (1 - midBase.x - 0.5) * 18; // åè½¬X
            const y = -(midBase.y - 0.5) * 10;
            
            shieldGroup.position.lerp(new THREE.Vector3(x, y, 0), 0.2);

            // æ—‹è½¬ (åŸºäºæ‰‹æŒæ³•çº¿)
            const tiltX = (midTip.y - wrist.y) * 4;
            const tiltY = ((1-midTip.x) - (1-wrist.x)) * 4;
            
            shieldGroup.rotation.x += (tiltX - shieldGroup.rotation.x) * 0.1;
            shieldGroup.rotation.y += (tiltY - shieldGroup.rotation.y) * 0.1;

            // è§†å·®ç‰¹æ•ˆ
            layerMid.position.x = shieldGroup.rotation.y * 0.5;
            layerOut.position.x = shieldGroup.rotation.y * 1.0;

            // ç¼©æ”¾ (åŸºäºæ‰‹æŒå¤§å°è‡ªé€‚åº”)
            // palmSize é€šå¸¸åœ¨ 0.1 ~ 0.3 ä¹‹é—´
            let scale = palmSize * 20; 
            if(currentState === 'CHAOS') scale *= 0.6; // æ¡æ‹³å˜å°
            shieldGroup.scale.lerp(new THREE.Vector3(scale, scale, scale), 0.1);
        }

        // === 5. åŠ¨ç”»å¾ªç¯ ===
        const clock = new THREE.Clock();
        function animate() {
            requestAnimationFrame(animate);
            const t = clock.getElapsedTime();
            
            let speed = 1;
            if(currentState === 'TIME') speed = -2;
            if(currentState === 'CHAOS') speed = 5;

            layerCore.rotation.z = t * 0.2 * speed;
            layerMid.rotation.z = -t * 0.15 * speed;
            layerOut.rotation.z = t * 0.05 * speed;
            timeRing.rotation.x = t * 2;
            timeRing.rotation.y = t * 0.5;

            // æ¡æ‹³æ—¶ç²’å­æŠ–åŠ¨
            if(currentState === 'CHAOS') {
                 const pPos = particles.geometry.attributes.position.array;
                 for(let i=0; i<pPos.length; i++) pPos[i] += (Math.random()-0.5)*0.1;
                 particles.geometry.attributes.position.needsUpdate = true;
            }

            composer.render();
        }

        window.addEventListener('resize', () => {
            camera3D.aspect = window.innerWidth/window.innerHeight;
            camera3D.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
